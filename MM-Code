main : Element
main = view (testState emptyState)
--main = collage 500 500 (fullView)


fullView : [Form]
fullView = tree
elseD = [ node "Node1"
  , spacer 30 30
  , node "Node2"
  , childNodes
  ]
 
node txt = color grey (container 100 50 middle (plainText txt))
 
rootNode = toForm (node "root")
 
tree = [rootNode, (moveX 130(toForm childNodes2))]
 
childNodes2 = flow down ( intersperse (spacer 50 30) listNodes )
listNodes = [node "n1", node "n2"]
 
childNodes = collage 200 200 nodes
nodes = [nodeForm "n1", (moveY 70 (nodeForm "n2"))]
nodeForm txt = toForm (node txt)


---- Model -----
-- Mind Map is a tree. The node can have multiple children
-- 

data MM_Node = MM_Node 
    {  nodeName   : String
    ,  childNodes : [MM_Node]
    ,  text       : String
    ,  collapsed  : Bool
    ,  parentNode : MM_Node
    } | MM_RootNode
    { nodeName : String
    ,  childNodes : [MM_Node]
    ,  text       : String
    ,  collapsed  : Bool
    }    

type State = 
    {  rootNode  : MM_Node
    ,  editNode  : MM_Node
    }

-- Create a new node with given parent
newMM_Node : MM_Node -> String -> MM_Node
newMM_Node p val = MM_Node
    {  nodeName   = ""
    ,  childNodes = []
    ,  text       = val
    ,  collapsed  = False
    ,  parentNode = p
    }

emptyState : State
emptyState = 
    let root = MM_RootNode { nodeName = "", childNodes = [], text = "", collapsed = False }
    in { rootNode = root, editNode = root }

addNode : MM_Node -> String -> MM_Node
addNode n val = 
    case n of
      (MM_Node node) ->
        let newN = newMM_Node n val
            updatedChildList = newN :: node.childNodes
        in MM_Node { node | childNodes <- updatedChildList }
      (MM_RootNode node) ->
        let newN = newMM_Node n val
            updatedChildList = newN :: node.childNodes
        in MM_RootNode { node | childNodes <- updatedChildList }

testState : State -> State
testState emptyS = 
    let n1 = addNode emptyS.rootNode "n1"
        n2 = addNode n1 "n2"
    in { emptyS | rootNode <- n2 }
---- View ----

view : State -> Element
view state = renderNode state.rootNode

renderNodeTxt txt = color grey (container 100 50 middle (plainText txt))

renderOneNode : MM_Node -> Element
renderOneNode n = 
    case n of 
      (MM_Node node) ->
        renderNodeTxt node.text
      (MM_RootNode node) ->
        renderNodeTxt node.text

renderNode : MM_Node -> Element
renderNode n =
    case n of 
      (MM_Node  node) ->
        let childNodeMap = map renderNode node.childNodes
            childMap = flow down ( intersperse (spacer 50 30) childNodeMap)
        in flow right [(renderOneNode n), (spacer 50 50), childMap]
      (MM_RootNode node) ->
        let childNodeMap = map renderNode node.childNodes
            childMap = flow down ( intersperse (spacer 50 30) childNodeMap)
        in flow right [(renderOneNode n), (spacer 50 50), childMap]
        
---- Update -----
